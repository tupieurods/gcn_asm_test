#define ARGON2_BLOCK_SIZE 1024
#define ARGON2_QWORDS_IN_BLOCK (ARGON2_BLOCK_SIZE / 8)

typedef union {
  ulong v[ARGON2_QWORDS_IN_BLOCK];
  uint vUint[ARGON2_QWORDS_IN_BLOCK * 2];
} block;

// index for first shift columns operation(after first ARGON2_P)
__constant uchar lindexes0[32][4] = {
  {0x00, 0x01, 0x02, 0x03},
  {0x01, 0x02, 0x03, 0x00},
  {0x02, 0x03, 0x00, 0x01},
  {0x03, 0x00, 0x01, 0x02},
  {0x04, 0x05, 0x06, 0x07},
  {0x05, 0x06, 0x07, 0x04},
  {0x06, 0x07, 0x04, 0x05},
  {0x07, 0x04, 0x05, 0x06},
  {0x08, 0x09, 0x0A, 0x0B},
  {0x09, 0x0A, 0x0B, 0x08},
  {0x0A, 0x0B, 0x08, 0x09},
  {0x0B, 0x08, 0x09, 0x0A},
  {0x0C, 0x0D, 0x0E, 0x0F},
  {0x0D, 0x0E, 0x0F, 0x0C},
  {0x0E, 0x0F, 0x0C, 0x0D},
  {0x0F, 0x0C, 0x0D, 0x0E},
  {0x10, 0x11, 0x12, 0x13},
  {0x11, 0x12, 0x13, 0x10},
  {0x12, 0x13, 0x10, 0x11},
  {0x13, 0x10, 0x11, 0x12},
  {0x14, 0x15, 0x16, 0x17},
  {0x15, 0x16, 0x17, 0x14},
  {0x16, 0x17, 0x14, 0x15},
  {0x17, 0x14, 0x15, 0x16},
  {0x18, 0x19, 0x1A, 0x1B},
  {0x19, 0x1A, 0x1B, 0x18},
  {0x1A, 0x1B, 0x18, 0x19},
  {0x1B, 0x18, 0x19, 0x1A},
  {0x1C, 0x1D, 0x1E, 0x1F},
  {0x1D, 0x1E, 0x1F, 0x1C},
  {0x1E, 0x1F, 0x1C, 0x1D},
  {0x1F, 0x1C, 0x1D, 0x1E}
};

__attribute__((reqd_work_group_size(32, 1, 8)))
__kernel void testKernel(__global block *matrixData)
{
  const uint gid = get_global_id(2) - get_global_offset(2);
  const uint lhid = get_local_id(2); // local hash id
  const uint laneSubThread = get_local_id(0);
  const uint localIdx1 = laneSubThread + 32;
  const uint localIdx2 = laneSubThread + 64;
  const uint localIdx3 = laneSubThread + 96;

  __local ulong exchangeBufferTotal[8 * ARGON2_QWORDS_IN_BLOCK];
  __local ulong *exchangeBuffer = exchangeBufferTotal + lhid * ARGON2_QWORDS_IN_BLOCK;
  
  matrixData += gid;

  ulong currentBlock[4];
  currentBlock[0] = matrixData->v[laneSubThread];
  currentBlock[1] = matrixData->v[localIdx1];
  currentBlock[2] = matrixData->v[localIdx2];
  currentBlock[3] = matrixData->v[localIdx3];

  #pragma unroll 4
  for(int i = 1; i < 4; i++)
  {
    exchangeBuffer[laneSubThread] = currentBlock[i];
    barrier(CLK_LOCAL_MEM_FENCE);
    currentBlock[i] = exchangeBuffer[lindexes0[laneSubThread][i]];
    barrier(CLK_LOCAL_MEM_FENCE);
  }

  matrixData->v[laneSubThread] = currentBlock[0];
  matrixData->v[localIdx1] = currentBlock[1];
  matrixData->v[localIdx2] = currentBlock[2];
  matrixData->v[localIdx3] = currentBlock[3];
}